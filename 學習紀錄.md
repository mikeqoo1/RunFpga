# 設計原則

Throughput：吞吐量定義單位時間內做特定的事情或是單位時間內產生多少結果

Memory bandwidth：記憶體頻寬是處理器可以從記憶體讀取資料或將資料儲存到記憶體的速率。

例如，一個電腦有兩個通道的記憶體，每通道都配備執行在400MHz時脈頻率的DDR2-800模組，則其理論最大記憶體頻寬為：
每秒400,000,000個時鐘×每個時鐘2個通道×每行64個位×2個介面=
每秒102,400,000,000（1024億）位元（也就是12,800MB/s或12.8GB/s）
但是該理論最大記憶體頻寬被稱為「突發速率」，是不可持續的。

就是想辦法越快越好。

等等要說的概念都是從大到小，從一個問題延伸出對應的想法。

# FPGA 程式設計的三大觀念

## Producer-Consumer Paradigm (生產者消費者問題)

我對生產者消費者問題的理解如下：

（可以把倉庫當一個緩衝區）

通常是指說倉庫大小為N，生產者把東西放到倉庫，消費者把東西從倉庫拿走。

互斥關係：對倉庫的訪問需要互斥，包括生產者和生產者之間、消費者和消費者之間、生產者和消費者之間。
同步關係：當倉庫滿的時候生產者需要等待，當倉庫空的時候消費者需要等待。

對 C++ 來說就是多執行緒的同步經典問題。

當然還有，單一生產者-多消費者模型，多生產者-單一消費者模型，多生產者-多消費者模型。

所以這題目對 FPGA 來說就是，我們寫程式的人要自己控管那些部分可以是被平行處理，不用上鎖的，哪些是要照順序處理的。

這邊我用單一生產者-單一消費者模型舉例說明：

當我要把產品放到倉庫，需要幫商品標好價錢。我可以先標好價錢再放到倉庫，這 2 件事情是不衝突的。

![生產者消費者](img/生產者消費者.png)

## Streaming Data Paradigm

Streaming （流）是比較抽象的概念，就是無限制的連續更新資料，其中“無限制”表示“大小未知或者大小無限”的資料。

生產者跟消費者之間的資料傳遞可以是流。

原文：

```txt
In software, random memory accesses to data are virtually free (ignoring the caching costs), but in hardware, it is really advantageous to make sequential accesses, which can be converted into streams.
```

在軟體設計中對記憶體裡的資料做隨機存取的代價很低也很快，但是硬體裡做順序存取是很棒的一件事，可以轉換成流的形式。

這邊用上面的例子來說明，假設多個產品要放到倉庫，但是都要標好價錢，如果採取單一生產者的方式會比較慢。

這邊的 A、B、C 商品，都需要標好價錢可以用流的方式給標價錢的任務，只要標價錢任務有辦法承受那些流量，就可以處理多種商品。

![流](img/流.png)

這邊有提到 2 個流傳輸的模式 FIFO 或 PIPO 這邊就先帶過處理。

這邊的理念就是，我們只需要專注在每個任務上，任務跟任務之間都用流溝通，然後不同的流之間還可以達到異步緩衝的功能。

當然也可以用流來幫我們的系統做分層。

## Pipelining Paradigm

這是一個最小的觀念



