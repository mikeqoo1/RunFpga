# 重要術語

1. LUT 或 SICE
LUT 或 SICE 是組成了 FPGA 的區域 它的數量有限, 當它用完時代表設計太大

2. RAM 或 Block RAM
FPGA 中的内存

3. Latency 延遲
- 設計產生结果所需的時脈頻率
- 循環的延遲是一次迭代所需的時脈頻率

4. Initiation Interval 或 II 或 Interval 間隔

- 在接受新資料之前必須執行的時脈頻率
跟延遲不一樣 如果函數是流水線的, 許多資料會同時流過它. 延遲是一個資料被推入後彈出的時間, 而時間間隔决定了資料可以被推入的速率

- 循環的間隔是可以開始循環迭代的最大速率, 以時脈頻率為單位

![說明圖](/img/說明圖.png)

左邊是函數 右邊是循環 左邊的時間間隔(在接收新資料前)是 3 個時脈頻率, 右邊循環的間隔則是一個時脈頻率；對於左邊的延遲是這個函數產生結果的時脈頻率數, 是 func_C 運行完畢產生的周期數, 為 5 個時脈頻率, 右邊循環的延遲是一次迭代所需的時鐘數, 是 4 個時脈頻率. 

# 重要指令

- Functions-函數
- Loops-循環
- Various-所有都適合
- Arrays-陣列
- Parameters-參數


| 指令 | 作用範圍 | 說明 |
| :----: | :----: | :----: |
| PIPELINE 流水線指令 | Functions, Loops | 就是使輸入更頻繁的傳给函數或循環. 流水線後的函數或循環可以每 N 個時脈頻率處理一次新輸入, 其中 N 是啟動間隔(Initiation Interval). 'II' 默認為 1, 是 HLS 應針對的啟動間隔(嘗試將新資料输入管道的速度應該多快). |
| UNROLL | Loops | 建立循環的因子副本, 可以併行執行(如果滿足資料流依賴性). 但是會浪費資源(以資源换取速度). 盡可能將程序展開以提高速度. |
| ALLOCATION | Various | 限制某事物的實際使用數. 例如, 如果只想在另一個函數 toplevel 中獲得函數 foo 的三個副本, 使用位置 toplevel, 限制設定為 3, 實例設定為 foo, 類型設定為 "function" 的分配. 這也適合用在特定的運算. |
| ARRAY_PARTITION | Arrays | 將一個大 Array 拆分為多個較小的 Array. 對於增加並行訪問的可能性很有用. 如果"type"是"block", 則 Array 將分成 block. 如果它是"cyclic", 那麼資料將被交錯到目標 Arraya 中. 在這兩種情况下, "factor 因子"都是要建立的較小 Array 的數量. 如果 'type' 是 'complete' 則忽略 'factor' 並且 Array 被完全分割成组件暫存器, 因此不使用任何 Block RAM. |
| DATAFLOW | Functions |  |
| INLINE | Functions | 該指令不是將函數視為單個硬體單元, 而是在每次調用 HLS 時將函數內聯. 以硬體為代價增加了潛在的並行性. 如果 'recursive' 為真, 則内聯函數调用的所有函數也被視為標有 INLINE. |
| INTERFACE |Function, Parameters | 告訴 HLS 如何在函數之間傳遞参數. 這在頂層函數中至關重要, 因為它定義了設計的引腳排列. 在 EMBS 中, 我们有一個應該堅持使用的模板. |
| LATENCY | Functions, Loops | HLS 通常會嘗試在综合時實現最小延遲. 如果使用此指令指定更大的最小延遲, HLS 將函數或循環並減慢一切. 這有助於資源共享(減少資源), 並且對於建立延遲很有用. 如果 HLS 無法達到要求的延遲, 它將發出警告. |
| LOOP_FLATTEN | Loops | 將多層迴圈展平為單個循環. 應用於最內層的循環. 如果成功, 會生成更快的硬體代碼. |
| LOOP_TRIPCOUNT | Loops | 如果循環具有可變的循環邊界, HLS 將不知道需要多少次迭代. 意味著無法為設計延遲提供明確的值. 這允許設計指定循環的最小, 平均和最大迭代次數. 這只會影響報告, 不會影響硬體代碼生成. |
| RESOURCE | Various | 用來指定使用特定硬體資源來實現 C 語言元素. 指定是否使用 BRAM 或 LUT 實現 ARRAY. |

# 任意精確度類型

HLS 中使用普通的 C 類型(int char 等)變量 但是硬體中的暫存器不用到 4 8 16 的 bit 寬度, 所以可以指定任意類型的精確度來定義要多寬的大小

C 語言範例:
```c
include <ap_cint.h>
uint5 x; // 無號整數, 寬度5
int19 x; // 有號整數, 寬度19
```

C++ 語言範例:
```c++
include <ap_int.h>
ap_uint<5> x; // 無號整數, 寬度5
ap_int<19> x; // 有號整數, 寬度19
```

# 復位行為

復位電路是一種用來使電路恢復到起始狀態的電路設備, 它的操作原理與計算器有著異曲同工之妙, 只是啓動原理和手段有所不同. 復位電路, 就是利用它把電路恢復到起始狀態, 就像計算器的清零按鈕的作用一樣, 以便回到原始狀態, 重新進行計算.

在 HLS 中, 所有靜態和全域變數都被初始化為零(如果有給初始值, 則初始化那個值) 包括 RAM, 其中每個元素都被清零. 
這種初始化只發生在 FPGA 首次編譯時. 任何後續處理器復位都不會觸發初始化過程.

如果需要清除設備的內部狀態, 應該包含某種復位協議(根据復位狀態處理所需要的程序)

# AXI 從接口和 AXI 主接口

# 多種類型的 AXI Master

# 强制和阻止使用 Block RAM

[原文](https://cloud.tencent.com/developer/article/2216860)